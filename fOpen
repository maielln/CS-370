#include <iostream>
#include <string>
#include <stdio.h>
#include <string.h>

using namespace std;

void read_file_to_buffer(FILE *);
char *buffer = NULL;
void cleanup();
int findLine (int);
string getLine (int);
void writeLine (string, FILE *);


/*
Written by Mark Yetter, using pre-existing code from Dr. Confer
Written in C++ (GNU GCC) using Code::Blocks
Last updated 2/3/18
When given a file path, opens an input and output file. Has the capability
to read lines from the input, edit them, and print lines in the output.
*/

int main (void)
{
    char inPath[80] = "C:/Users/MCYet/Desktop/School/Y2S2/CS 370/fOpen/f.txt";
    char outPath[80] = "C:/Users/MCYet/Desktop/School/Y2S2/CS 370/fOpen/fOut.txt";
    FILE * roboFile = NULL;
    FILE * outFile = NULL;

	atexit(cleanup);

	roboFile = fopen(inPath, "rb");
	if (roboFile == NULL)
	{
        cout << "Could not find input file at " << inPath;
        exit(EXIT_FAILURE);
	}
	outFile = fopen(outPath, "wb");
	if (outFile == NULL)
    {
        cout << "Error opening output file at " << outPath;
        exit(EXIT_FAILURE);
    }

	read_file_to_buffer(roboFile);
	fclose (roboFile);

    string temp = getLine(0);
    int i = 1;
    for (i=1;temp!="";i++)
    {
        writeLine (temp, outFile);
        temp = getLine(i);
    }

    fclose (outFile);
	free(buffer);
	buffer = NULL;

    exit(EXIT_SUCCESS);
}


void read_file_to_buffer(FILE *f) {
	long file_size = 0;

	if(buffer != NULL) {
		fprintf(stderr, "Buffer in use\n");
		exit(EXIT_FAILURE);
	}

	rewind(f);
	if(fseek(f, 0, SEEK_END) != 0) {
		perror("Couldn't seek to end of file");
		exit(EXIT_FAILURE);
	}

	file_size = ftell(f);
	if(file_size < 0) {
		perror("Couldn't tell size");
		exit(EXIT_FAILURE);
	}
	rewind(f);

	buffer = (char *)malloc(sizeof(char) * (file_size + 1));
	if(buffer == NULL) {
		fprintf(stderr, "Could not allocate buffer\n");
		exit(EXIT_FAILURE);
	}

	if(fread(buffer, sizeof(char), (size_t)file_size, f) != file_size) {
		fprintf(stderr, "Couldn't read file\n");
		exit(EXIT_FAILURE);
	}
	buffer[file_size] = '\0';

	return;
}

void cleanup()
{

	return;
}

int findLine (int lNum)
{
    int index = 0, position = 0;

    if (lNum == 0)
        return 0;

    for (position=0; index<lNum; position++)
    {
        if (buffer[position] == '\0')
        {
            return -1;
        }
        else if (buffer[position] == '\r')
        {
            index++;
        }
    }

    return position+1;
}

string getLine (int lNum)
{
    int index = 0, position = 0;
    string line = "";

    position = findLine(lNum);
    if (position < 0)
        return "";

    for (index=0; index<1; position++)
    {
        if (buffer[position]=='\r' || buffer[position]=='\0')
        {
            line += buffer[position];
            index++;
        }
        else
            line += buffer[position];
    }

    return line;
}

void writeLine (string line, FILE *f)
{
    const char * cLine = line.c_str();

    fputs(cLine, f);
    fputs("\r\n", f);

    return;
}
